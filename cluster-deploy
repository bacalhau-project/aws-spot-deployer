#!/bin/bash
set -e

# Global Cluster Deployment Tool
# Simple one-command deployment of clusters worldwide using SkyPilot

SCRIPT_NAME="cluster-deploy"
DEFAULT_CONFIG="cluster.yaml"
DEFAULT_CLUSTER="cluster"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
BOLD='\033[1m'
NC='\033[0m' # No Color

DOCKER_CONTAINER_NAME="skypilot-cluster-deploy"
SKYPILOT_IMAGE="berkeleyskypilot/skypilot"

# Global logging configuration
LOG_TO_CONSOLE=false  # By default, log to file
LOG_FILE="cluster-deploy.log"

# Function to run sky commands in Docker container
run_sky_cmd() {
    # Ensure Docker container is running
    ensure_docker_container

    # Execute sky command in container
    docker exec "$DOCKER_CONTAINER_NAME" sky "$@"
}

# Function to ensure Docker container is running
ensure_docker_container() {
    # Check if container is already running
    if ! docker ps --filter "name=$DOCKER_CONTAINER_NAME" --filter "status=running" --quiet | grep -q .; then
        log_info "Starting SkyPilot Docker container..."

        # Remove any existing stopped container with same name
        docker rm "$DOCKER_CONTAINER_NAME" >/dev/null 2>&1 || true

        # Start new container with volume mounts (includes AWS SSO support)
        docker run -td --rm --name "$DOCKER_CONTAINER_NAME" \
          -v "$HOME/.sky:/root/.sky:rw" \
          -v "$HOME/.aws:/root/.aws:rw" \
          -v "$HOME/.config/gcloud:/root/.config/gcloud:rw" \
          -v "$(pwd):/workspace:rw" \
          -w /workspace \
          "$SKYPILOT_IMAGE" >/dev/null

        if [ $? -eq 0 ]; then
            log_success "SkyPilot Docker container started"
        else
            log_error "Failed to start SkyPilot Docker container"
            return 1
        fi
    fi
}

# Logging functions
log_message() {
    local level="$1"
    local color="$2"
    local message="$3"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    if [[ "$LOG_TO_CONSOLE" == true ]]; then
        echo -e "${color}[$level]${NC} $message"
    else
        # Write to log file (without color codes for file)
        echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
        # Also show brief status to console
        echo -e "${color}[$level]${NC} $message"
    fi
}

log_info() {
    log_message "INFO" "$BLUE" "$1"
}

log_success() {
    log_message "SUCCESS" "$GREEN" "$1"
}

log_warning() {
    log_message "WARNING" "$YELLOW" "$1"
}

log_error() {
    log_message "ERROR" "$RED" "$1"
}

log_header() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    if [[ "$LOG_TO_CONSOLE" == true ]]; then
        echo ""
        echo -e "${BOLD}${BLUE}ðŸŒ $1${NC}"
        echo ""
    else
        # Write to log file
        echo "" >> "$LOG_FILE"
        echo "[$timestamp] [HEADER] ðŸŒ $1" >> "$LOG_FILE"
        echo "" >> "$LOG_FILE"
        # Also show on console
        echo ""
        echo -e "${BOLD}${BLUE}ðŸŒ $1${NC}"
        echo ""
    fi
}

# Get version from git tag with SHA suffix for dev builds
get_version() {
    if command -v git >/dev/null 2>&1; then
        # Try to get the latest git tag
        if git describe --tags --exact-match HEAD >/dev/null 2>&1; then
            # On a tagged commit
            tag=$(git describe --tags --exact-match HEAD 2>/dev/null)
            echo "${tag#v}"  # Remove leading 'v' if present
        elif git describe --tags --always --dirty >/dev/null 2>&1; then
            # Not on a tagged commit, get tag + SHA
            tag_sha=$(git describe --tags --always --dirty 2>/dev/null)
            echo "${tag_sha#v}"  # Remove leading 'v' from tag
        elif git rev-parse --short HEAD >/dev/null 2>&1; then
            # Just SHA
            sha=$(git rev-parse --short HEAD 2>/dev/null)
            echo "dev-${sha}"
        else
            echo "dev-unknown"
        fi
    else
        echo "dev-unknown"
    fi
}

SCRIPT_VERSION=$(get_version)

# Extract cluster name from YAML config file
get_cluster_name_from_config() {
    local config_file="$1"
    if [[ -f "$config_file" ]]; then
        # Extract name field from YAML (handles both 'name:' and 'name :' with optional quotes)
        local yaml_name=$(grep -E "^name\s*:" "$config_file" | sed -E 's/^name\s*:\s*//; s/["\x27]//g' | xargs)
        if [[ -n "$yaml_name" ]]; then
            echo "$yaml_name"
            return 0
        fi
    fi
    echo "$DEFAULT_CLUSTER"
    return 1
}

# Check and install prerequisites
check_prerequisites() {
    log_header "Checking Prerequisites"

    # Check if Docker is installed and running
    if ! command -v docker >/dev/null 2>&1; then
        log_error "Docker not found. Please install Docker first."
        log_info "Visit: https://docs.docker.com/get-docker/"
        return 1
    fi

    if ! docker info >/dev/null 2>&1; then
        log_error "Docker daemon is not running. Please start Docker first."
        return 1
    fi

    log_success "Docker is available and running"

    # Pull SkyPilot Docker image if not present
    log_info "Ensuring SkyPilot Docker image is available..."
    if ! docker image inspect "$SKYPILOT_IMAGE" >/dev/null 2>&1; then
        log_info "Pulling SkyPilot Docker image (this may take a few minutes)..."
        if ! docker pull "$SKYPILOT_IMAGE"; then
            log_error "Failed to pull SkyPilot Docker image"
            return 1
        fi
    fi

    # Test SkyPilot availability in container
    if ! run_sky_cmd --version >/dev/null 2>&1; then
        log_error "SkyPilot not available in Docker container"
        return 1
    fi

    local sky_version=$(run_sky_cmd --version 2>/dev/null | head -1)
    log_success "SkyPilot available: $sky_version"

    # Check AWS credentials (optional)
    if [[ -f "$HOME/.aws/credentials" ]] || [[ -n "$AWS_ACCESS_KEY_ID" ]]; then
        # Test AWS credentials through Docker container
        if run_sky_cmd check 2>/dev/null | grep -q "AWS: enabled"; then
            local account=$(aws sts get-caller-identity --no-paginate --query 'Account' --output text 2>/dev/null || echo "unknown")
            log_success "AWS credentials available (Account: $account)"
        else
            log_warning "AWS credentials configured but not working with SkyPilot"
        fi
    else
        log_warning "AWS credentials not found. Configure them in ~/.aws/ before deployment."
    fi

    return 0
}

# Deploy cluster using SkyPilot
deploy_cluster() {
    local config_file="$1"
    local cluster_name="$2"

    log_header "Deploying Global Cluster: $cluster_name"

    if [[ ! -f "$config_file" ]]; then
        log_error "Config file not found: $config_file"
        log_info "Create a SkyPilot YAML config file first"
        return 1
    fi

    log_info "Using config: $config_file"
    log_info "Cluster name: $cluster_name"

    # Set deployment ID for resource tagging
    local deployment_id="cluster-deploy-$(date +%Y%m%d%H%M%S)"
    export CLUSTER_DEPLOYMENT_ID="$deployment_id"
    log_info "Deployment ID: $deployment_id"

    # Launch cluster directly (avoids S3 storage and managed jobs complexity)
    log_info "Launching cluster (this may take 5-10 minutes)..."

    # Redirect deployment output based on logging mode
    local launch_result
    if [[ "$LOG_TO_CONSOLE" == true ]]; then
        # Show output to console when -f flag is used
        launch_result=$(run_sky_cmd launch "$config_file" --name "$cluster_name" --yes 2>&1)
        echo "$launch_result"
        launch_exit_code=$?
    else
        # Redirect verbose output to log file by default, show minimal progress
        echo "Deploying cluster... (check $LOG_FILE for detailed progress)"
        launch_result=$(run_sky_cmd launch "$config_file" --name "$cluster_name" --yes 2>&1)
        echo "$launch_result" >> "$LOG_FILE"
        launch_exit_code=$?
    fi

    if [ $launch_exit_code -eq 0 ]; then
        log_success "Cluster '$cluster_name' deployed successfully!"

        echo ""
        echo -e "${GREEN}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
        echo -e "${GREEN}â”‚               ðŸŽ‰ Deployment Complete            â”‚${NC}"
        echo -e "${GREEN}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
        echo -e "${GREEN}â”‚ Next Steps:                                     â”‚${NC}"
        echo -e "${GREEN}â”‚ â€¢ Check status: ./cluster-deploy status        â”‚${NC}"
        echo -e "${GREEN}â”‚ â€¢ SSH to cluster: ./cluster-deploy ssh         â”‚${NC}"
        echo -e "${GREEN}â”‚ â€¢ View logs: ./cluster-deploy logs             â”‚${NC}"
        echo -e "${GREEN}â”‚ â€¢ Destroy cluster: ./cluster-deploy destroy    â”‚${NC}"
        echo -e "${GREEN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
        echo ""
        return 0
    else
        log_error "Deployment failed"
        return 1
    fi
}

# Get actual SkyPilot cluster name (not YAML name)
get_sky_cluster_name() {
    # Get the first running cluster from sky status
    local sky_cluster=$(run_sky_cmd status --format json 2>/dev/null | jq -r '.clusters[0].name // empty' 2>/dev/null)
    if [[ -n "$sky_cluster" ]]; then
        echo "$sky_cluster"
        return 0
    fi

    # Fallback: parse text output
    local sky_cluster=$(run_sky_cmd status 2>/dev/null | grep -E "^[a-z0-9-]+" | head -1 | awk '{print $1}')
    if [[ -n "$sky_cluster" ]]; then
        echo "$sky_cluster"
        return 0
    fi

    return 1
}

# Show cluster status
show_status() {
    log_header "Cluster Status"
    run_sky_cmd status
}

# SSH to cluster (head node)
ssh_cluster() {
    # Get the actual SkyPilot cluster name
    local sky_cluster=$(get_sky_cluster_name)
    if [[ -z "$sky_cluster" ]]; then
        log_error "No running cluster found"
        return 1
    fi

    log_info "Connecting to head node of cluster: $sky_cluster"

    # Use Docker exec with interactive terminal to SSH into cluster
    docker exec -it "$DOCKER_CONTAINER_NAME" ssh "$sky_cluster"
}

# Show cluster logs
show_logs() {
    # Get the actual SkyPilot cluster name
    local sky_cluster=$(get_sky_cluster_name)
    if [[ -z "$sky_cluster" ]]; then
        log_error "No running cluster found"
        return 1
    fi

    log_info "Showing logs for cluster: $sky_cluster"
    run_sky_cmd logs "$sky_cluster"
}

# Destroy cluster
destroy_cluster() {
    # Get the actual SkyPilot cluster name
    local sky_cluster=$(get_sky_cluster_name)
    if [[ -z "$sky_cluster" ]]; then
        log_info "No running cluster found to destroy"
        return 0
    fi

    log_header "Destroying Cluster: $sky_cluster"
    log_warning "This will terminate all instances and delete all data!"

    # Capture the output to check if cluster exists
    local output
    output=$(run_sky_cmd down "$sky_cluster" --yes 2>&1)
    local exit_code=$?

    if [ $exit_code -eq 0 ]; then
        if echo "$output" | grep -q "not found"; then
            log_info "Cluster '$sky_cluster' does not exist"
        else
            log_success "Cluster '$sky_cluster' destroyed"
        fi
        return 0
    else
        log_error "Failed to destroy cluster"
        echo "$output"
        return 1
    fi
}

# Clean up Docker container
cleanup_docker() {
    if docker ps --filter "name=$DOCKER_CONTAINER_NAME" --quiet | grep -q .; then
        log_info "Stopping SkyPilot Docker container..."
        docker stop "$DOCKER_CONTAINER_NAME" >/dev/null 2>&1
        log_success "Docker container stopped"
    fi
}

# List cluster nodes with detailed information
list_nodes() {
    # Get the actual SkyPilot cluster name
    local sky_cluster=$(get_sky_cluster_name)
    if [[ -z "$sky_cluster" ]]; then
        log_error "No running cluster found"
        return 1
    fi

    log_header "Cluster Nodes: $sky_cluster"

    # Get cluster info with more details
    local cluster_info
    cluster_info=$(run_sky_cmd status --name "$sky_cluster" 2>/dev/null)

    if [[ $? -ne 0 ]] || [[ -z "$cluster_info" ]]; then
        log_error "Failed to get cluster information"
        return 1
    fi

    # Parse launch time from cluster info
    local launch_time=$(echo "$cluster_info" | grep -E "^$sky_cluster" | awk '{print $6, $7, $8}')

    # Get detailed cluster information using exec to run commands on the cluster
    log_info "Gathering node information..."

    # Try to get instance IDs and IPs using sky exec
    local node_data
    node_data=$(run_sky_cmd exec "$sky_cluster" 'curl -s http://169.254.169.254/latest/meta-data/instance-id 2>/dev/null && echo "," && curl -s http://169.254.169.254/latest/meta-data/public-ipv4 2>/dev/null && echo "," && curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null' 2>/dev/null | tr -d '\n')

    # Create table header
    printf "\n"
    printf "${BOLD}%-15s %-20s %-15s %-15s %-12s${NC}\n" "NODE" "INSTANCE_ID" "PUBLIC_IP" "ZONE" "LAUNCHED"
    printf "%-15s %-20s %-15s %-15s %-12s\n" "----" "-----------" "---------" "----" "--------"

    # Get number of nodes from config
    local num_nodes=$(grep -E "^num_nodes\\s*:" cluster.yaml 2>/dev/null | sed -E 's/^num_nodes\\s*:\\s*//' | xargs)
    if [[ -z "$num_nodes" ]] || ! [[ "$num_nodes" =~ ^[0-9]+$ ]]; then
        num_nodes=9
    fi

    # Display basic info for all nodes (since we can't easily query each individually)
    for ((i=0; i<num_nodes; i++)); do
        printf "%-15s %-20s %-15s %-15s %-12s\n" \
            "node-$i" \
            "querying..." \
            "querying..." \
            "various" \
            "$launch_time"
    done

    printf "\n"
    echo -e "${GREEN}Total nodes: $num_nodes${NC}"
    echo -e "${GREEN}Cluster status: UP${NC}"
    echo ""
}

# Show help
show_help() {
    cat << EOF

${BOLD}${BLUE}Global Cluster Deployment Tool v${SCRIPT_VERSION}${NC}

${BOLD}USAGE:${NC}
  ./cluster-deploy [COMMAND] [OPTIONS]

  # Or via curl (when hosted):
  curl https://tada.wang/install.sh | bash -s -- [COMMAND] [OPTIONS]

${BOLD}COMMANDS:${NC}
  create      Deploy global cluster
  destroy     Destroy the cluster
  status      Show cluster status
  list        Show detailed node information
  ssh         SSH to cluster
  logs        Show cluster logs
  cleanup     Stop Docker container
  help        Show this help

${BOLD}OPTIONS:${NC}
  -c FILE     Config file (default: ${DEFAULT_CONFIG})
  -n NAME     Cluster name (default: from config file)
  -f          Show logs to console instead of log file

${BOLD}EXAMPLES:${NC}
  # Deploy with default settings
  ./cluster-deploy create

  # Deploy with custom config
  ./cluster-deploy create -c my-config.yaml -n my-cluster

  # Check status
  ./cluster-deploy status

  # Destroy cluster
  ./cluster-deploy destroy

${BOLD}QUICK START:${NC}
  1. Ensure Docker is installed and running
  2. Ensure AWS credentials are configured in ~/.aws/
  3. Create ${DEFAULT_CONFIG} in your current directory
  4. Run: ./cluster-deploy create
  5. Wait 5-10 minutes for global deployment
  6. Access with: ./cluster-deploy ssh

${BOLD}GLOBAL ZONES SUPPORTED:${NC}
  â€¢ US West (Oregon) - us-west-2
  â€¢ US East (Virginia) - us-east-1
  â€¢ Europe (Ireland) - eu-west-1
  â€¢ Asia Pacific (Mumbai) - ap-south-1
  â€¢ Asia Pacific (Sydney) - ap-southeast-2
  â€¢ South America (SÃ£o Paulo) - sa-east-1
  â€¢ Plus additional zones for redundancy

EOF
}

# Parse command line arguments
config_file="$DEFAULT_CONFIG"
cluster_name=""  # Will be set after parsing config file
command="help"

while [[ $# -gt 0 ]]; do
    case $1 in
        create|deploy)
            command="create"
            shift
            ;;
        destroy|down)
            command="destroy"
            shift
            ;;
        status)
            command="status"
            shift
            ;;
        list)
            command="list"
            shift
            ;;
        ssh)
            command="ssh"
            shift
            ;;
        logs)
            command="logs"
            shift
            ;;
        cleanup)
            command="cleanup"
            shift
            ;;
        help|--help|-h)
            command="help"
            shift
            ;;
        -c|--config)
            config_file="$2"
            shift 2
            ;;
        -n|--name)
            cluster_name="$2"
            shift 2
            ;;
        -f|--console)
            LOG_TO_CONSOLE=true
            shift
            ;;
        *)
            if [[ -z "$command" ]] || [[ "$command" == "help" ]]; then
                command="$1"
            fi
            shift
            ;;
    esac
done

# Set cluster name from YAML config if not specified via command line
if [[ -z "$cluster_name" ]]; then
    cluster_name=$(get_cluster_name_from_config "$config_file")
fi

# Main execution
echo -e "${BLUE}Global Cluster Deployment Tool v${SCRIPT_VERSION}${NC}"

case "$command" in
    create)
        if ! check_prerequisites; then
            exit 1
        fi
        if ! deploy_cluster "$config_file" "$cluster_name"; then
            exit 1
        fi
        ;;
    destroy)
        if ! destroy_cluster; then
            exit 1
        fi
        ;;
    status)
        if ! check_prerequisites; then
            exit 1
        fi
        show_status
        ;;
    list)
        if ! check_prerequisites; then
            exit 1
        fi
        list_nodes
        ;;
    ssh)
        if ! check_prerequisites; then
            exit 1
        fi
        ssh_cluster
        ;;
    logs)
        if ! check_prerequisites; then
            exit 1
        fi
        show_logs
        ;;
    cleanup)
        cleanup_docker
        ;;
    help)
        show_help
        ;;
    *)
        log_error "Unknown command: $command"
        show_help
        exit 1
        ;;
esac
